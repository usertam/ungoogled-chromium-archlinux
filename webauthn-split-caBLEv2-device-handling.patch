# f71ddba855036d7b1fda6ffb59390ff827f48acb

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 2eb4e37..75bb2f19 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -4426,6 +4426,8 @@
       "webauthn/authenticator_request_scheduler.cc",
       "webauthn/authenticator_request_scheduler.h",
       "webauthn/authenticator_transport.h",
+      "webauthn/cablev2_devices.cc",
+      "webauthn/cablev2_devices.h",
       "webauthn/chrome_authenticator_request_delegate.cc",
       "webauthn/chrome_authenticator_request_delegate.h",
       "webauthn/observable_authenticator_list.cc",
diff --git a/chrome/browser/webauthn/authenticator_request_dialog_model.cc b/chrome/browser/webauthn/authenticator_request_dialog_model.cc
index 4427cf4..59db14e 100644
--- a/chrome/browser/webauthn/authenticator_request_dialog_model.cc
+++ b/chrome/browser/webauthn/authenticator_request_dialog_model.cc
@@ -132,12 +132,6 @@
 AuthenticatorRequestDialogModel::PairedPhone::operator=(const PairedPhone&) =
     default;
 
-bool AuthenticatorRequestDialogModel::PairedPhone::CompareByName(
-    const PairedPhone& a,
-    const PairedPhone& b) {
-  return a.name < b.name;
-}
-
 void AuthenticatorRequestDialogModel::EphemeralState::Reset() {
   selected_authenticator_id_ = absl::nullopt;
   saved_authenticators_.RemoveAllAuthenticators();
@@ -663,16 +657,11 @@
   contact_phone_callback_ = std::move(contact_phone_callback);
   cable_qr_string_ = cable_qr_string;
 
-  std::stable_sort(paired_phones_.begin(), paired_phones_.end(),
-                   PairedPhone::CompareByName);
   paired_phones_contacted_.assign(paired_phones_.size(), false);
 }
 
 std::vector<std::string> AuthenticatorRequestDialogModel::paired_phone_names()
     const {
-  DCHECK(std::is_sorted(paired_phones_.begin(), paired_phones_.end(),
-                        PairedPhone::CompareByName));
-
   std::vector<std::string> names;
   std::transform(paired_phones_.begin(), paired_phones_.end(),
                  std::back_inserter(names),
@@ -804,9 +793,6 @@
 
 void AuthenticatorRequestDialogModel::ContactNextPhoneByName(
     const std::string& name) {
-  DCHECK(std::is_sorted(paired_phones_.begin(), paired_phones_.end(),
-                        PairedPhone::CompareByName));
-
   bool found_name = false;
   for (size_t i = 0; i != paired_phones_.size(); i++) {
     const PairedPhone& phone = paired_phones_[i];
diff --git a/chrome/browser/webauthn/authenticator_request_dialog_model_unittest.cc b/chrome/browser/webauthn/authenticator_request_dialog_model_unittest.cc
index 461d078..44aa065 100644
--- a/chrome/browser/webauthn/authenticator_request_dialog_model_unittest.cc
+++ b/chrome/browser/webauthn/authenticator_request_dialog_model_unittest.cc
@@ -197,8 +197,8 @@
 
       // If there are linked phones then AOA doesn't show up, but the phones do,
       // and sorted. The selection sheet should show.
-      {mc, {usb, aoa, cable}, {}, {"b", "a"}, {t(usb), p("a"), p("b")}, mss},
-      {ga, {usb, aoa, cable}, {}, {"b", "a"}, {t(usb), p("a"), p("b")}, mss},
+      {mc, {usb, aoa, cable}, {}, {"a", "b"}, {t(usb), p("a"), p("b")}, mss},
+      {ga, {usb, aoa, cable}, {}, {"a", "b"}, {t(usb), p("a"), p("b")}, mss},
 
       // On Windows, if there are linked phones we'll show a selection sheet.
       {mc, {cable}, {has_winapi}, {"a"}, {winapi, p("a")}, mss},
diff --git a/chrome/browser/webauthn/cablev2_devices.cc b/chrome/browser/webauthn/cablev2_devices.cc
new file mode 100644
index 0000000..028d92d
--- /dev/null
+++ b/chrome/browser/webauthn/cablev2_devices.cc
@@ -0,0 +1,355 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/webauthn/cablev2_devices.h"
+
+#include "base/base64.h"
+#include "base/feature_list.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/sync/device_info_sync_service_factory.h"
+#include "chrome/common/pref_names.h"
+#include "components/pref_registry/pref_registry_syncable.h"
+#include "components/prefs/pref_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "components/sync_device_info/device_info.h"
+#include "components/sync_device_info/device_info_sync_service.h"
+#include "components/sync_device_info/device_info_tracker.h"
+#include "device/fido/cable/cable_discovery_data.h"
+#include "device/fido/cable/v2_handshake.h"
+#include "device/fido/features.h"
+
+using device::cablev2::Pairing;
+
+namespace cablev2 {
+
+namespace {
+
+template <size_t N>
+bool CopyBytestring(std::array<uint8_t, N>* out, const std::string* value) {
+  if (!value) {
+    return false;
+  }
+
+  std::string bytes;
+  if (!base::Base64Decode(*value, &bytes) || bytes.size() != N) {
+    return false;
+  }
+
+  std::copy(bytes.begin(), bytes.end(), out->begin());
+  return true;
+}
+
+bool CopyBytestring(std::vector<uint8_t>* out, const std::string* value) {
+  if (!value) {
+    return false;
+  }
+
+  std::string bytes;
+  if (!base::Base64Decode(*value, &bytes)) {
+    return false;
+  }
+
+  out->clear();
+  out->insert(out->begin(), bytes.begin(), bytes.end());
+  return true;
+}
+
+bool CopyString(std::string* out, const std::string* value) {
+  if (!value) {
+    return false;
+  }
+  *out = *value;
+  return true;
+}
+
+const char kWebAuthnCablePairingsPrefName[] = "webauthn.cablev2_pairings";
+
+// The `kWebAuthnCablePairingsPrefName` preference contains a list of dicts,
+// where each dict has these keys:
+const char kPairingPrefName[] = "name";
+const char kPairingPrefContactId[] = "contact_id";
+const char kPairingPrefTunnelServer[] = "tunnel_server";
+const char kPairingPrefId[] = "id";
+const char kPairingPrefSecret[] = "secret";
+const char kPairingPrefPublicKey[] = "pub_key";
+const char kPairingPrefTime[] = "time";
+
+// NameForDisplay removes line-breaking characters from `raw_name` to ensure
+// that the transport-selection UI isn't too badly broken by nonsense names.
+static std::string NameForDisplay(base::StringPiece raw_name) {
+  std::u16string unicode_name = base::UTF8ToUTF16(raw_name);
+  base::StringPiece16 trimmed_name =
+      base::TrimWhitespace(unicode_name, base::TRIM_ALL);
+  // These are all the Unicode mandatory line-breaking characters
+  // (https://www.unicode.org/reports/tr14/tr14-32.html#Properties).
+  constexpr char16_t kLineTerminators[] = {0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028,
+                                           0x2029,
+                                           // Array must be NUL terminated.
+                                           0};
+  std::u16string nonbreaking_name;
+  base::RemoveChars(trimmed_name, kLineTerminators, &nonbreaking_name);
+  return base::UTF16ToUTF8(nonbreaking_name);
+}
+
+// DeletePairingByPublicKey erases any pairing with the given public key
+// from `list`.
+void DeletePairingByPublicKey(base::ListValue* list,
+                              const std::string& public_key_base64) {
+  list->EraseListValueIf([&public_key_base64](const auto& value) {
+    if (!value.is_dict()) {
+      return false;
+    }
+    const base::Value* pref_public_key = value.FindKey(kPairingPrefPublicKey);
+    return pref_public_key && pref_public_key->is_string() &&
+           pref_public_key->GetString() == public_key_base64;
+  });
+}
+
+// PairingFromSyncedDevice extracts the caBLEv2 information from Sync's
+// DeviceInfo (if any) into a caBLEv2 pairing. It may return nullptr.
+std::unique_ptr<Pairing> PairingFromSyncedDevice(syncer::DeviceInfo* device,
+                                                 const base::Time& now) {
+  if (device->last_updated_timestamp() < now) {
+    const base::TimeDelta age = now - device->last_updated_timestamp();
+    if (age.InHours() > 24 * 14) {
+      // Entries older than 14 days are dropped. If changing this, consider
+      // updating `cablev2::sync::IDIsValid` too so that the mobile-side is
+      // aligned.
+      return nullptr;
+    }
+  }
+
+  const absl::optional<syncer::DeviceInfo::PhoneAsASecurityKeyInfo>&
+      maybe_paask_info = device->paask_info();
+  if (!maybe_paask_info) {
+    return nullptr;
+  }
+
+  const syncer::DeviceInfo::PhoneAsASecurityKeyInfo& paask_info =
+      *maybe_paask_info;
+  auto pairing = std::make_unique<Pairing>();
+  pairing->from_sync_deviceinfo = true;
+  pairing->name = NameForDisplay(device->client_name());
+
+  const absl::optional<device::cablev2::tunnelserver::KnownDomainID>
+      tunnel_server_domain = device::cablev2::tunnelserver::ToKnownDomainID(
+          paask_info.tunnel_server_domain);
+  if (!tunnel_server_domain) {
+    // It's possible that a phone is running a more modern version of Chrome
+    // and uses an assigned tunnel server domain that is unknown to this code.
+    return nullptr;
+  }
+
+  pairing->tunnel_server_domain =
+      device::cablev2::tunnelserver::DecodeDomain(*tunnel_server_domain);
+  pairing->contact_id = paask_info.contact_id;
+  pairing->peer_public_key_x962 = paask_info.peer_public_key_x962;
+  pairing->secret.assign(paask_info.secret.begin(), paask_info.secret.end());
+  pairing->last_updated = device->last_updated_timestamp();
+
+  // The pairing ID from sync is zero-padded to the standard length.
+  pairing->id.assign(device::cablev2::kPairingIDSize, 0);
+  static_assert(device::cablev2::kPairingIDSize >= sizeof(paask_info.id), "");
+  memcpy(pairing->id.data(), &paask_info.id, sizeof(paask_info.id));
+
+  // The channel priority is only approximate and exists to help testing and
+  // development. I.e. we want the development or Canary install on a device to
+  // shadow the stable channel so that it's possible to test things. This code
+  // is matching the string generated by `FormatUserAgentForSync`.
+  const std::string& user_agent = device->sync_user_agent();
+  if (user_agent.find("-devel") != std::string::npos) {
+    pairing->channel_priority = 5;
+  } else if (user_agent.find("(canary)") != std::string::npos) {
+    pairing->channel_priority = 4;
+  } else if (user_agent.find("(dev)") != std::string::npos) {
+    pairing->channel_priority = 3;
+  } else if (user_agent.find("(beta)") != std::string::npos) {
+    pairing->channel_priority = 2;
+  } else if (user_agent.find("(stable)") != std::string::npos) {
+    pairing->channel_priority = 1;
+  } else {
+    pairing->channel_priority = 0;
+  }
+
+  return pairing;
+}
+
+std::vector<std::unique_ptr<Pairing>> GetSyncedDevices(Profile* const profile) {
+  std::vector<std::unique_ptr<Pairing>> ret;
+  syncer::DeviceInfoSyncService* const sync_service =
+      DeviceInfoSyncServiceFactory::GetForProfile(profile);
+  if (!sync_service) {
+    return ret;
+  }
+
+  syncer::DeviceInfoTracker* const tracker =
+      sync_service->GetDeviceInfoTracker();
+  std::vector<std::unique_ptr<syncer::DeviceInfo>> devices =
+      tracker->GetAllDeviceInfo();
+
+  const base::Time now = base::Time::Now();
+  for (const auto& device : devices) {
+    std::unique_ptr<Pairing> pairing =
+        PairingFromSyncedDevice(device.get(), now);
+    if (!pairing) {
+      continue;
+    }
+    ret.emplace_back(std::move(pairing));
+  }
+
+  return ret;
+}
+
+std::vector<std::unique_ptr<Pairing>> GetLinkedDevices(Profile* const profile) {
+  PrefService* const prefs = profile->GetPrefs();
+  const base::ListValue* pref_pairings =
+      prefs->GetList(kWebAuthnCablePairingsPrefName);
+
+  std::vector<std::unique_ptr<Pairing>> ret;
+  for (const auto& pairing : pref_pairings->GetList()) {
+    if (!pairing.is_dict()) {
+      continue;
+    }
+
+    auto out_pairing = std::make_unique<Pairing>();
+    if (!CopyString(&out_pairing->name,
+                    pairing.FindStringKey(kPairingPrefName)) ||
+        !CopyString(&out_pairing->tunnel_server_domain,
+                    pairing.FindStringKey(kPairingPrefTunnelServer)) ||
+        !CopyBytestring(&out_pairing->contact_id,
+                        pairing.FindStringKey(kPairingPrefContactId)) ||
+        !CopyBytestring(&out_pairing->id,
+                        pairing.FindStringKey(kPairingPrefId)) ||
+        !CopyBytestring(&out_pairing->secret,
+                        pairing.FindStringKey(kPairingPrefSecret)) ||
+        !CopyBytestring(&out_pairing->peer_public_key_x962,
+                        pairing.FindStringKey(kPairingPrefPublicKey))) {
+      continue;
+    }
+
+    out_pairing->name = NameForDisplay(out_pairing->name);
+    ret.emplace_back(std::move(out_pairing));
+  }
+
+  return ret;
+}
+
+}  // namespace
+
+void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
+  registry->RegisterListPref(kWebAuthnCablePairingsPrefName);
+}
+
+KnownDevices::KnownDevices() = default;
+KnownDevices::~KnownDevices() = default;
+
+// static
+std::unique_ptr<KnownDevices> KnownDevices::FromProfile(Profile* profile) {
+  if (profile->IsOffTheRecord()) {
+    // For Incognito windows we collect the devices from the parent profile.
+    // The `AuthenticatorRequestDialogModel` will notice that it's an OTR
+    // profile and display a confirmation interstitial for makeCredential calls.
+    profile = profile->GetOriginalProfile();
+  }
+
+  auto ret = std::make_unique<KnownDevices>();
+  ret->synced_devices = GetSyncedDevices(profile);
+  ret->linked_devices = GetLinkedDevices(profile);
+  return ret;
+}
+
+std::vector<std::unique_ptr<Pairing>> MergeDevices(
+    std::unique_ptr<KnownDevices> known_devices,
+    const icu::Locale* locale) {
+  std::vector<std::unique_ptr<Pairing>> ret;
+  ret.swap(known_devices->synced_devices);
+  std::sort(ret.begin(), ret.end(), Pairing::CompareByMostRecentFirst);
+
+  for (auto& pairing : known_devices->linked_devices) {
+    ret.emplace_back(std::move(pairing));
+  }
+
+  // All the pairings from sync come first in `ret`, sorted by most recent
+  // first, followed by pairings from prefs, which are known to have unique
+  // public keys within themselves. A stable sort by public key will group
+  // together any pairings for the same Chrome instance, preferring recent sync
+  // records, then `std::unique` will delete all but the first.
+  std::stable_sort(ret.begin(), ret.end(), Pairing::CompareByPublicKey);
+  ret.erase(std::unique(ret.begin(), ret.end(), Pairing::EqualPublicKeys),
+            ret.end());
+
+  // ret now contains only a single entry per Chrome install. There can still be
+  // multiple entries for a given name, however. Sort by most recent and then by
+  // channel. That means that, considering all the entries for a given name,
+  // Sync entries on unstable channels have top priority. Within a given
+  // channel, the most recent entry has priority.
+
+  std::sort(ret.begin(), ret.end(), Pairing::CompareByMostRecentFirst);
+  std::stable_sort(ret.begin(), ret.end(),
+                   Pairing::CompareByLeastStableChannelFirst);
+
+  // Last, sort by name while preserving the order of entries with the same
+  // name.
+  std::stable_sort(ret.begin(), ret.end(), Pairing::CompareByName(locale));
+
+  return ret;
+}
+
+void AddPairing(PrefService* pref_service, std::unique_ptr<Pairing> pairing) {
+  // This is called when doing a QR-code pairing with a phone and the phone
+  // sends long-term pairing information during the handshake. The pairing
+  // information is saved in preferences for future operations.
+  if (!base::FeatureList::IsEnabled(device::kWebAuthPhoneSupport)) {
+    NOTREACHED();
+    return;
+  }
+
+  // For Incognito/Guest profiles, pairings will only last for the duration of
+  // that session. While an argument could be made that it's safe to persist
+  // such pairing for longer, this seems like the safe option initially.
+  ListPrefUpdate update(pref_service, kWebAuthnCablePairingsPrefName);
+
+  // Find any existing entries with the same public key and replace them. The
+  // handshake protocol requires the phone to prove possession of the public
+  // key so it's not possible for an evil phone to displace another's pairing.
+  std::string public_key_base64 =
+      base::Base64Encode(pairing->peer_public_key_x962);
+  DeletePairingByPublicKey(update.Get(), public_key_base64);
+
+  auto dict = std::make_unique<base::Value>(base::Value::Type::DICTIONARY);
+  dict->SetKey(kPairingPrefPublicKey,
+               base::Value(std::move(public_key_base64)));
+  dict->SetKey(kPairingPrefTunnelServer,
+               base::Value(pairing->tunnel_server_domain));
+  dict->SetKey(kPairingPrefName, base::Value(std::move(pairing->name)));
+  dict->SetKey(kPairingPrefContactId,
+               base::Value(base::Base64Encode(pairing->contact_id)));
+  dict->SetKey(kPairingPrefId, base::Value(base::Base64Encode(pairing->id)));
+  dict->SetKey(kPairingPrefSecret,
+               base::Value(base::Base64Encode(pairing->secret)));
+
+  base::Time::Exploded now;
+  base::Time::Now().UTCExplode(&now);
+  dict->SetKey(kPairingPrefTime,
+               // RFC 3339 time format.
+               base::Value(base::StringPrintf(
+                   "%04d-%02d-%02dT%02d:%02d:%02dZ", now.year, now.month,
+                   now.day_of_month, now.hour, now.minute, now.second)));
+
+  update->Append(std::move(dict));
+}
+
+// DeletePairingByPublicKey erases any pairing with the given public key
+// from `list`.
+void DeletePairingByPublicKey(
+    PrefService* pref_service,
+    std::array<uint8_t, device::kP256X962Length> public_key) {
+  ListPrefUpdate update(pref_service, kWebAuthnCablePairingsPrefName);
+  DeletePairingByPublicKey(update.Get(), base::Base64Encode(public_key));
+}
+
+}  // namespace cablev2
diff --git a/chrome/browser/webauthn/cablev2_devices.h b/chrome/browser/webauthn/cablev2_devices.h
new file mode 100644
index 0000000..01348b5
--- /dev/null
+++ b/chrome/browser/webauthn/cablev2_devices.h
@@ -0,0 +1,91 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_WEBAUTHN_CABLEV2_DEVICES_H_
+#define CHROME_BROWSER_WEBAUTHN_CABLEV2_DEVICES_H_
+
+#include <memory>
+#include <vector>
+
+#include "device/fido/fido_constants.h"
+#include "third_party/abseil-cpp/absl/types/variant.h"
+#include "third_party/icu/source/common/unicode/locid.h"
+
+class PrefService;
+class Profile;
+
+namespace user_prefs {
+class PrefRegistrySyncable;
+}
+
+namespace device {
+namespace cablev2 {
+struct Pairing;
+}  // namespace cablev2
+}  // namespace device
+
+namespace cablev2 {
+
+// RegisterProfilePrefs registers any preferences used by these functions. This
+// must be called at browser startup otherwise the preferences won't be
+// usable.
+void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);
+
+// KnownDevices reflects the browser's knowledge of known caBLEv2 devices.
+// caBLEv2 is the protocol used when phones are acting as security keys. (Except
+// for the case where accounts.google.com is using caBLEv1, but Chrome doesn't
+// store any state for caBLEv1.)
+//
+// There are two sources of caBLEv2 pairing information: DeviceInfo entries in
+// Sync, and information sent by the phone during a QR-initiated transaction.
+// DeviceInfo state is managed by Sync. Information from phones is kept in
+// preferences. These sources are referred to in variable names as "synced"
+// and "linked" devices.
+//
+// (Preferences may be synced, and thus information about "linked" phones may be
+// synced around. But that is separate from learning about phones because they
+// are signed into the same account and are publishing DeviceInfo records into
+// Sync.)
+//
+// Call `FromProfile` to load the information from sync data and preferences.
+// Alternatively, for testing, information can be added directly to the
+// vectors.
+struct KnownDevices {
+  KnownDevices();
+  ~KnownDevices();
+  KnownDevices(const KnownDevices&) = delete;
+  KnownDevices(const KnownDevices&&) = delete;
+  KnownDevices& operator=(const KnownDevices&) = delete;
+
+  // FromProfile returns a `KnownDevices` by extracting them from the
+  // Sync data and preferencs of `browser_context`.
+  static std::unique_ptr<KnownDevices> FromProfile(Profile* profile);
+
+  std::vector<std::unique_ptr<device::cablev2::Pairing>> synced_devices;
+  std::vector<std::unique_ptr<device::cablev2::Pairing>> linked_devices;
+};
+
+// MergeDevices returns a merged and sorted list of pairings, suitable for
+// display in UI. There may be sequential `Pairing`s with the same name.
+// These should be merged before display and are returned in priority order for
+// connections. Devices are sorted by name based on the given locale, which
+// should be `icu::Locale::getDefault` in real code but should be a fixed locale
+// in tests.
+std::vector<std::unique_ptr<device::cablev2::Pairing>> MergeDevices(
+    std::unique_ptr<KnownDevices>,
+    const icu::Locale* locale);
+
+// AddPairing records `pairing` in `pref_service`, displacing any existing
+// pairing with the same public key.
+void AddPairing(PrefService* pref_service,
+                std::unique_ptr<device::cablev2::Pairing> pairing);
+
+// DeletePairingByPublicKey erases a pairing from `pref_service` by public key.
+void DeletePairingByPublicKey(
+    PrefService* pref_service,
+    std::array<uint8_t, device::kP256X962Length> public_key);
+
+}  // namespace cablev2
+
+#endif  // CHROME_BROWSER_WEBAUTHN_CABLEV2_DEVICES_H_
diff --git a/chrome/browser/webauthn/cablev2_devices_unittest.cc b/chrome/browser/webauthn/cablev2_devices_unittest.cc
new file mode 100644
index 0000000..96045de
--- /dev/null
+++ b/chrome/browser/webauthn/cablev2_devices_unittest.cc
@@ -0,0 +1,240 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <memory>
+#include <vector>
+
+#include "base/test/scoped_feature_list.h"
+#include "base/time/time.h"
+#include "chrome/browser/webauthn/cablev2_devices.h"
+#include "chrome/test/base/testing_profile.h"
+#include "content/public/test/browser_task_environment.h"
+#include "device/fido/cable/cable_discovery_data.h"
+#include "device/fido/features.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using cablev2::KnownDevices;
+using cablev2::MergeDevices;
+using device::cablev2::Pairing;
+
+namespace {
+
+enum class Channel {
+  UNKNOWN = 0,
+  STABLE = 1,
+  BETA = 2,
+  DEV = 3,
+  CANARY = 4,
+  DEVELOPER = 5,
+};
+
+constexpr uint8_t kPubKey1 = 1;
+constexpr uint8_t kPubKey2 = 2;
+constexpr uint8_t kPubKey3 = 3;
+constexpr uint8_t kPubKey4 = 4;
+constexpr uint8_t kPubKey5 = 5;
+constexpr uint8_t kPubKey6 = 6;
+constexpr uint8_t kPubKey7 = 7;
+constexpr uint8_t kPubKey8 = 8;
+
+const base::Time kTime9 = base::Time::FromTimeT(9);
+const base::Time kTime10 = base::Time::FromTimeT(10);
+const base::Time kTime11 = base::Time::FromTimeT(11);
+
+std::unique_ptr<Pairing> SyncedDevice(const char* name,
+                                      uint8_t public_key_id,
+                                      Channel channel,
+                                      base::Time update) {
+  auto ret = std::make_unique<Pairing>();
+  ret->name = name;
+  ret->from_sync_deviceinfo = true;
+  ret->last_updated = update;
+  ret->channel_priority = static_cast<int>(channel);
+  ret->peer_public_key_x962 = {0};
+  ret->peer_public_key_x962[0] = public_key_id;
+  return ret;
+}
+
+std::unique_ptr<Pairing> LinkedDevice(const char* name, uint8_t public_key_id) {
+  auto ret = std::make_unique<Pairing>();
+  ret->name = name;
+  ret->peer_public_key_x962 = {0};
+  ret->peer_public_key_x962[0] = public_key_id;
+  return ret;
+}
+
+TEST(CableV2DeviceMerging, SyncOverridesForSameDevice) {
+  // If there's a record from the same device (i.e. same public key) obtained
+  // via syncing and linking, syncing takes priority.
+  auto known_devices = std::make_unique<KnownDevices>();
+  known_devices->synced_devices.emplace_back(
+      SyncedDevice("S1", kPubKey1, Channel::STABLE, kTime10));
+  known_devices->linked_devices.emplace_back(LinkedDevice("L1", kPubKey1));
+
+  std::vector<std::unique_ptr<Pairing>> result =
+      MergeDevices(std::move(known_devices), &icu::Locale::getUS());
+
+  ASSERT_EQ(result.size(), 1u);
+  EXPECT_EQ(result[0]->name, "S1");
+}
+
+TEST(CableV2DeviceMerging, MostRecentSyncFirst) {
+  // If there are multiple pairings for the same device (i.e. same public key)
+  // then the most recent sync takes priority.
+  auto known_devices = std::make_unique<KnownDevices>();
+  std::vector<std::unique_ptr<Pairing>>& synced = known_devices->synced_devices;
+  synced.emplace_back(SyncedDevice("S1", kPubKey1, Channel::STABLE, kTime10));
+  synced.emplace_back(SyncedDevice("S1", kPubKey1, Channel::STABLE, kTime9));
+  synced.emplace_back(SyncedDevice("S1", kPubKey1, Channel::STABLE, kTime11));
+
+  std::vector<std::unique_ptr<Pairing>> result =
+      MergeDevices(std::move(known_devices), &icu::Locale::getUS());
+
+  ASSERT_EQ(result.size(), 1u);
+  EXPECT_EQ(result[0]->name, "S1");
+  EXPECT_EQ(result[0]->last_updated, kTime11);
+}
+
+TEST(CableV2DeviceMerging, SyncOrderedByChannel) {
+  // Multiple Sync records from different installations on the same device are
+  // ordered by unstable channel first and then by update time. Pairings with
+  // the same name should be grouped together.
+  auto known_devices = std::make_unique<KnownDevices>();
+  std::vector<std::unique_ptr<Pairing>>& synced = known_devices->synced_devices;
+  synced.emplace_back(SyncedDevice("S1", kPubKey1, Channel::STABLE, kTime10));
+  synced.emplace_back(SyncedDevice("S1", kPubKey2, Channel::BETA, kTime10));
+  synced.emplace_back(SyncedDevice("S1", kPubKey3, Channel::DEV, kTime9));
+  synced.emplace_back(SyncedDevice("S1", kPubKey4, Channel::DEV, kTime10));
+  synced.emplace_back(SyncedDevice("S2", kPubKey5, Channel::STABLE, kTime10));
+  synced.emplace_back(SyncedDevice("S1", kPubKey6, Channel::DEV, kTime11));
+  synced.emplace_back(SyncedDevice("S1", kPubKey7, Channel::CANARY, kTime10));
+  synced.emplace_back(
+      SyncedDevice("S1", kPubKey8, Channel::DEVELOPER, kTime10));
+
+  std::vector<std::unique_ptr<Pairing>> result =
+      MergeDevices(std::move(known_devices), &icu::Locale::getUS());
+
+  std::vector<std::unique_ptr<Pairing>> expected;
+  expected.emplace_back(
+      SyncedDevice("S1", kPubKey1, Channel::DEVELOPER, kTime10));
+  expected.emplace_back(SyncedDevice("S1", kPubKey1, Channel::CANARY, kTime10));
+  expected.emplace_back(SyncedDevice("S1", kPubKey1, Channel::DEV, kTime11));
+  expected.emplace_back(SyncedDevice("S1", kPubKey1, Channel::DEV, kTime10));
+  expected.emplace_back(SyncedDevice("S1", kPubKey1, Channel::DEV, kTime9));
+  expected.emplace_back(SyncedDevice("S1", kPubKey1, Channel::BETA, kTime10));
+  expected.emplace_back(SyncedDevice("S1", kPubKey1, Channel::STABLE, kTime10));
+  expected.emplace_back(SyncedDevice("S2", kPubKey2, Channel::STABLE, kTime10));
+
+  ASSERT_EQ(result.size(), expected.size());
+  for (size_t i = 0; i < result.size(); i++) {
+    SCOPED_TRACE(i);
+
+    EXPECT_EQ(result[i]->name, expected[i]->name);
+    EXPECT_EQ(result[i]->channel_priority, expected[i]->channel_priority);
+    EXPECT_EQ(result[i]->last_updated, expected[i]->last_updated);
+  }
+}
+
+TEST(CableV2DeviceMerging, Alphabetical) {
+  // Names of different devices should be sorted alphabetically.
+  auto known_devices = std::make_unique<KnownDevices>();
+  std::vector<std::unique_ptr<Pairing>>& s = known_devices->synced_devices;
+  s.emplace_back(SyncedDevice("Charlie", kPubKey1, Channel::STABLE, kTime10));
+  s.emplace_back(SyncedDevice("Alice", kPubKey2, Channel::STABLE, kTime10));
+  s.emplace_back(SyncedDevice("Bob", kPubKey3, Channel::STABLE, kTime10));
+  std::vector<std::unique_ptr<Pairing>>& l = known_devices->linked_devices;
+  l.emplace_back(LinkedDevice("Denise", kPubKey4));
+  l.emplace_back(LinkedDevice("alicia", kPubKey5));
+
+  std::vector<std::unique_ptr<Pairing>> result =
+      MergeDevices(std::move(known_devices), &icu::Locale::getUS());
+
+  std::vector<std::string> expected = {
+      "Alice", "alicia", "Bob", "Charlie", "Denise",
+  };
+
+  ASSERT_EQ(result.size(), expected.size());
+  for (size_t i = 0; i < result.size(); i++) {
+    SCOPED_TRACE(i);
+    EXPECT_EQ(result[i]->name, expected[i]);
+  }
+}
+
+class CableV2DevicesProfileTest : public testing::Test {
+  // A `BrowserTaskEnvironment` needs to be in-scope in order to create a
+  // `TestingProfile`.
+  content::BrowserTaskEnvironment task_environment_;
+  base::test::ScopedFeatureList scoped_feature_list_{
+      device::kWebAuthPhoneSupport};
+};
+
+TEST_F(CableV2DevicesProfileTest, InitiallyEmpty) {
+  TestingProfile profile;
+
+  std::unique_ptr<KnownDevices> known_devices =
+      KnownDevices::FromProfile(&profile);
+
+  EXPECT_EQ(known_devices->synced_devices.size(), 0u);
+  EXPECT_EQ(known_devices->linked_devices.size(), 0u);
+}
+
+std::unique_ptr<Pairing> PairingWithAllFields() {
+  auto ret = std::make_unique<Pairing>();
+  ret->contact_id = {1, 2, 3, 4, 5};
+  ret->id = {6, 7, 8, 9, 10};
+  ret->secret = {11, 12, 13, 14, 15};
+  ret->peer_public_key_x962 = {16, 17, 18, 19, 20};
+  ret->name = "Pairing";
+  return ret;
+}
+
+TEST_F(CableV2DevicesProfileTest, StoreAndFetch) {
+  TestingProfile profile;
+  cablev2::AddPairing(profile.GetPrefs(), PairingWithAllFields());
+
+  std::unique_ptr<KnownDevices> known_devices =
+      KnownDevices::FromProfile(&profile);
+
+  EXPECT_EQ(known_devices->synced_devices.size(), 0u);
+  ASSERT_EQ(known_devices->linked_devices.size(), 1u);
+
+  std::unique_ptr<Pairing> expected = PairingWithAllFields();
+  const Pairing* const found = known_devices->linked_devices[0].get();
+  EXPECT_EQ(found->contact_id, expected->contact_id);
+  EXPECT_EQ(found->id, expected->id);
+  EXPECT_EQ(found->secret, expected->secret);
+  EXPECT_EQ(found->peer_public_key_x962, expected->peer_public_key_x962);
+  EXPECT_EQ(found->name, expected->name);
+  EXPECT_EQ(found->from_sync_deviceinfo, expected->from_sync_deviceinfo);
+}
+
+TEST_F(CableV2DevicesProfileTest, Delete) {
+  TestingProfile profile;
+  cablev2::AddPairing(profile.GetPrefs(), PairingWithAllFields());
+  cablev2::DeletePairingByPublicKey(
+      profile.GetPrefs(), PairingWithAllFields()->peer_public_key_x962);
+
+  std::unique_ptr<KnownDevices> known_devices =
+      KnownDevices::FromProfile(&profile);
+
+  EXPECT_EQ(known_devices->synced_devices.size(), 0u);
+  EXPECT_EQ(known_devices->linked_devices.size(), 0u);
+}
+
+TEST_F(CableV2DevicesProfileTest, NameFiltering) {
+  // The pairing name is stored as sent by the device, but any newlines are
+  // removed when reading so that they don't mess up the UI.
+  TestingProfile profile;
+  cablev2::AddPairing(profile.GetPrefs(),
+                      LinkedDevice("w\nx\x0by\xe2\x80\xa8z", kPubKey1));
+
+  std::unique_ptr<KnownDevices> known_devices =
+      KnownDevices::FromProfile(&profile);
+
+  EXPECT_EQ(known_devices->synced_devices.size(), 0u);
+  ASSERT_EQ(known_devices->linked_devices.size(), 1u);
+  EXPECT_EQ(known_devices->linked_devices[0]->name, "wxyz");
+}
+
+}  // namespace
diff --git a/chrome/browser/webauthn/chrome_authenticator_request_delegate.cc b/chrome/browser/webauthn/chrome_authenticator_request_delegate.cc
index 2becd355..94dc086 100644
--- a/chrome/browser/webauthn/chrome_authenticator_request_delegate.cc
+++ b/chrome/browser/webauthn/chrome_authenticator_request_delegate.cc
@@ -13,9 +13,6 @@
 #include "base/callback.h"
 #include "base/feature_list.h"
 #include "base/location.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/time/time.h"
 #include "base/values.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -29,6 +26,7 @@
 #include "chrome/browser/ui/page_action/page_action_icon_type.h"
 #include "chrome/browser/ui/webauthn/authenticator_request_dialog.h"
 #include "chrome/browser/webauthn/authenticator_request_dialog_model.h"
+#include "chrome/browser/webauthn/cablev2_devices.h"
 #include "chrome/common/chrome_switches.h"
 #include "chrome/common/chrome_version.h"
 #include "chrome/common/pref_names.h"
@@ -36,10 +34,6 @@
 #include "components/device_event_log/device_event_log.h"
 #include "components/pref_registry/pref_registry_syncable.h"
 #include "components/prefs/pref_service.h"
-#include "components/prefs/scoped_user_pref_update.h"
-#include "components/sync_device_info/device_info.h"
-#include "components/sync_device_info/device_info_sync_service.h"
-#include "components/sync_device_info/device_info_tracker.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/device_service.h"
@@ -50,6 +44,7 @@
 #include "device/fido/features.h"
 #include "device/fido/fido_authenticator.h"
 #include "device/fido/fido_discovery_factory.h"
+#include "third_party/icu/source/common/unicode/locid.h"
 #include "ui/base/l10n/l10n_util.h"
 
 #if defined(OS_MAC)
@@ -86,94 +81,11 @@
                      });
 }
 
-std::string Base64(base::span<const uint8_t> in) {
-  std::string ret;
-  base::Base64Encode(
-      base::StringPiece(reinterpret_cast<const char*>(in.data()), in.size()),
-      &ret);
-  return ret;
-}
-
-absl::optional<std::string> GetString(const base::Value& dict,
-                                      const char* key) {
-  const base::Value* v = dict.FindKey(key);
-  if (!v || !v->is_string()) {
-    return absl::nullopt;
-  }
-  return v->GetString();
-}
-
-template <size_t N>
-bool CopyBytestring(std::array<uint8_t, N>* out,
-                    absl::optional<std::string> value) {
-  if (!value) {
-    return false;
-  }
-
-  std::string bytes;
-  if (!base::Base64Decode(*value, &bytes) || bytes.size() != N) {
-    return false;
-  }
-
-  std::copy(bytes.begin(), bytes.end(), out->begin());
-  return true;
-}
-
-bool CopyBytestring(std::vector<uint8_t>* out,
-                    absl::optional<std::string> value) {
-  if (!value) {
-    return false;
-  }
-
-  std::string bytes;
-  if (!base::Base64Decode(*value, &bytes)) {
-    return false;
-  }
-
-  out->clear();
-  out->insert(out->begin(), bytes.begin(), bytes.end());
-  return true;
-}
-
-bool CopyString(std::string* out, absl::optional<std::string> value) {
-  if (!value) {
-    return false;
-  }
-  *out = *value;
-  return true;
-}
-
 #if defined(OS_MAC)
 const char kWebAuthnTouchIdMetadataSecretPrefName[] =
     "webauthn.touchid.metadata_secret";
 #endif
 
-const char kWebAuthnCablePairingsPrefName[] = "webauthn.cablev2_pairings";
-
-// The |kWebAuthnCablePairingsPrefName| preference contains a list of dicts,
-// where each dict has these keys:
-const char kPairingPrefName[] = "name";
-const char kPairingPrefContactId[] = "contact_id";
-const char kPairingPrefTunnelServer[] = "tunnel_server";
-const char kPairingPrefId[] = "id";
-const char kPairingPrefSecret[] = "secret";
-const char kPairingPrefPublicKey[] = "pub_key";
-const char kPairingPrefTime[] = "time";
-
-// DeleteCablePairingByPublicKey erases any pairing with the given public key
-// from |list|.
-void DeleteCablePairingByPublicKey(base::ListValue* list,
-                                   const std::string& public_key_base64) {
-  list->EraseListValueIf([&public_key_base64](const auto& value) {
-    if (!value.is_dict()) {
-      return false;
-    }
-    const base::Value* pref_public_key = value.FindKey(kPairingPrefPublicKey);
-    return pref_public_key && pref_public_key->is_string() &&
-           pref_public_key->GetString() == public_key_base64;
-  });
-}
-
 }  // namespace
 
 // ---------------------------------------------------------------------
@@ -323,8 +235,7 @@
   registry->RegisterStringPref(kWebAuthnTouchIdMetadataSecretPrefName,
                                std::string());
 #endif
-
-  registry->RegisterListPref(kWebAuthnCablePairingsPrefName);
+  cablev2::RegisterProfilePrefs(registry);
 }
 
 ChromeAuthenticatorRequestDelegate::ChromeAuthenticatorRequestDelegate(
@@ -500,7 +411,24 @@
     DCHECK(phone_names_.empty());
     DCHECK(phone_public_keys_.empty());
 
-    paired_phones = GetCablePairings();
+    std::unique_ptr<cablev2::KnownDevices> known_devices =
+        cablev2::KnownDevices::FromProfile(
+            Profile::FromBrowserContext(GetBrowserContext()));
+    if (g_observer) {
+      known_devices->synced_devices =
+          g_observer->GetCablePairingsFromSyncedDevices();
+    }
+    paired_phones = cablev2::MergeDevices(std::move(known_devices),
+                                          &icu::Locale::getDefault());
+
+    // The debug log displays in reverse order, so the headline is emitted after
+    // the names.
+    for (const auto& pairing : paired_phones) {
+      FIDO_LOG(DEBUG) << "• " << pairing->name << " " << pairing->last_updated
+                      << " priority:" << pairing->channel_priority;
+    }
+    FIDO_LOG(DEBUG) << "Found " << paired_phones.size() << " caBLEv2 devices";
+
     if (!paired_phones.empty()) {
       for (size_t i = 0; i < paired_phones.size(); i++) {
         const auto& phone = paired_phones[i];
@@ -774,208 +702,16 @@
   return origin.IsSameOriginWith(url::Origin::Create(test_site));
 }
 
-// NameForDisplay removes line-breaking characters from |raw_name| to ensure
-// that the transport-selection UI isn't too badly broken by nonsense names.
-static std::string NameForDisplay(base::StringPiece raw_name) {
-  std::u16string unicode_name = base::UTF8ToUTF16(raw_name);
-  base::StringPiece16 trimmed_name =
-      base::TrimWhitespace(unicode_name, base::TRIM_ALL);
-  // These are all the Unicode mandatory line-breaking characters
-  // (https://www.unicode.org/reports/tr14/tr14-32.html#Properties).
-  constexpr char16_t kLineTerminators[] = {0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028,
-                                           0x2029,
-                                           // Array must be NUL terminated.
-                                           0};
-  std::u16string nonbreaking_name;
-  base::RemoveChars(trimmed_name, kLineTerminators, &nonbreaking_name);
-  return base::UTF16ToUTF8(nonbreaking_name);
-}
-
-// PairingFromSyncedDevice extracts the caBLEv2 information from Sync's
-// DeviceInfo (if any) into a caBLEv2 pairing. It may return nullptr.
-static std::unique_ptr<device::cablev2::Pairing> PairingFromSyncedDevice(
-    syncer::DeviceInfo* device,
-    const base::Time& now) {
-  if (device->last_updated_timestamp() < now) {
-    const base::TimeDelta age = now - device->last_updated_timestamp();
-    if (age.InHours() > 24 * 14) {
-      // Entries older than 14 days are dropped. If changing this, consider
-      // updating |cablev2::sync::IDIsValid| too so that the mobile-side is
-      // aligned.
-      return nullptr;
-    }
-  }
-
-  const absl::optional<syncer::DeviceInfo::PhoneAsASecurityKeyInfo>&
-      maybe_paask_info = device->paask_info();
-  if (!maybe_paask_info) {
-    return nullptr;
-  }
-
-  const syncer::DeviceInfo::PhoneAsASecurityKeyInfo& paask_info =
-      *maybe_paask_info;
-  auto pairing = std::make_unique<device::cablev2::Pairing>();
-  pairing->name = NameForDisplay(device->client_name());
-
-  const absl::optional<device::cablev2::tunnelserver::KnownDomainID>
-      tunnel_server_domain = device::cablev2::tunnelserver::ToKnownDomainID(
-          paask_info.tunnel_server_domain);
-  if (!tunnel_server_domain) {
-    // It's possible that a phone is running a more modern version of Chrome
-    // and uses an assigned tunnel server domain that is unknown to this code.
-    return nullptr;
-  }
-
-  pairing->tunnel_server_domain =
-      device::cablev2::tunnelserver::DecodeDomain(*tunnel_server_domain);
-  pairing->contact_id = paask_info.contact_id;
-  pairing->peer_public_key_x962 = paask_info.peer_public_key_x962;
-  pairing->secret.assign(paask_info.secret.begin(), paask_info.secret.end());
-  pairing->last_updated = device->last_updated_timestamp();
-
-  // The pairing ID from sync is zero-padded to the standard length.
-  pairing->id.assign(device::cablev2::kPairingIDSize, 0);
-  static_assert(device::cablev2::kPairingIDSize >= sizeof(paask_info.id), "");
-  memcpy(pairing->id.data(), &paask_info.id, sizeof(paask_info.id));
-
-  // The channel priority is only approximate and exists to help testing and
-  // development. I.e. we want the development or Canary install on a device to
-  // shadow the stable channel so that it's possible to test things. This code
-  // is matching the string generated by |FormatUserAgentForSync|.
-  const std::string& user_agent = device->sync_user_agent();
-  if (user_agent.find("-devel") != std::string::npos) {
-    pairing->channel_priority = 5;
-  } else if (user_agent.find("(canary)") != std::string::npos) {
-    pairing->channel_priority = 4;
-  } else if (user_agent.find("(dev)") != std::string::npos) {
-    pairing->channel_priority = 3;
-  } else if (user_agent.find("(beta)") != std::string::npos) {
-    pairing->channel_priority = 2;
-  } else if (user_agent.find("(stable)") != std::string::npos) {
-    pairing->channel_priority = 1;
-  } else {
-    pairing->channel_priority = 0;
-  }
-
-  return pairing;
-}
-
-static std::vector<std::unique_ptr<device::cablev2::Pairing>>
-GetCablePairingsFromSyncedDevices(Profile* profile) {
-  if (g_observer) {
-    return g_observer->GetCablePairingsFromSyncedDevices();
-  }
-
-  std::vector<std::unique_ptr<device::cablev2::Pairing>> ret;
-  syncer::DeviceInfoSyncService* const sync_service =
-      DeviceInfoSyncServiceFactory::GetForProfile(profile);
-  if (!sync_service) {
-    return ret;
-  }
-
-  syncer::DeviceInfoTracker* const tracker =
-      sync_service->GetDeviceInfoTracker();
-  std::vector<std::unique_ptr<syncer::DeviceInfo>> devices =
-      tracker->GetAllDeviceInfo();
-
-  const base::Time now = base::Time::Now();
-  for (const auto& device : devices) {
-    std::unique_ptr<device::cablev2::Pairing> pairing =
-        PairingFromSyncedDevice(device.get(), now);
-    if (!pairing) {
-      continue;
-    }
-    ret.emplace_back(std::move(pairing));
-  }
-
-  return ret;
-}
-
-std::vector<std::unique_ptr<device::cablev2::Pairing>>
-ChromeAuthenticatorRequestDelegate::GetCablePairings() {
-  Profile* profile = Profile::FromBrowserContext(GetBrowserContext());
-  if (profile->IsOffTheRecord()) {
-    // For Incognito windows we collect the devices from the parent profile.
-    // The |AuthenticatorRequestDialogModel| will notice that it's an OTR
-    // profile and display a confirmation interstitial for makeCredential calls.
-    profile = profile->GetOriginalProfile();
-  }
-
-  std::vector<std::unique_ptr<device::cablev2::Pairing>> ret =
-      GetCablePairingsFromSyncedDevices(profile);
-  std::sort(ret.begin(), ret.end(),
-            device::cablev2::Pairing::CompareByMostRecentFirst);
-
-  PrefService* const prefs = profile->GetPrefs();
-  const base::ListValue* pref_pairings =
-      prefs->GetList(kWebAuthnCablePairingsPrefName);
-
-  for (const auto& pairing : pref_pairings->GetList()) {
-    if (!pairing.is_dict()) {
-      continue;
-    }
-
-    auto out_pairing = std::make_unique<device::cablev2::Pairing>();
-    if (!CopyString(&out_pairing->name, GetString(pairing, kPairingPrefName)) ||
-        !CopyString(&out_pairing->tunnel_server_domain,
-                    GetString(pairing, kPairingPrefTunnelServer)) ||
-        !CopyBytestring(&out_pairing->contact_id,
-                        GetString(pairing, kPairingPrefContactId)) ||
-        !CopyBytestring(&out_pairing->id, GetString(pairing, kPairingPrefId)) ||
-        !CopyBytestring(&out_pairing->secret,
-                        GetString(pairing, kPairingPrefSecret)) ||
-        !CopyBytestring(&out_pairing->peer_public_key_x962,
-                        GetString(pairing, kPairingPrefPublicKey))) {
-      continue;
-    }
-
-    out_pairing->name = NameForDisplay(out_pairing->name);
-    ret.emplace_back(std::move(out_pairing));
-  }
-
-  // All the pairings from sync come first in |ret|, sorted by most recent
-  // first, followed by pairings from prefs, which are known to have unique
-  // public keys within themselves. A stable sort by public key will group
-  // together any pairings for the same Chrome instance, preferring recent sync
-  // records, then |std::unique| will delete all but the first.
-  std::stable_sort(ret.begin(), ret.end(),
-                   device::cablev2::Pairing::CompareByPublicKey);
-  ret.erase(std::unique(ret.begin(), ret.end(),
-                        device::cablev2::Pairing::EqualPublicKeys),
-            ret.end());
-
-  // ret now contains only a single entry per Chrome install. There can still be
-  // multiple entries for a given name, however. Sort by most recent and then by
-  // channel. That means that, considering all the entries for a given name,
-  // Sync entries on unstable channels have top priority. Within a given
-  // channel, the most recent entry has priority.
-
-  std::sort(ret.begin(), ret.end(),
-            device::cablev2::Pairing::CompareByMostRecentFirst);
-  std::stable_sort(ret.begin(), ret.end(),
-                   device::cablev2::Pairing::CompareByLeastStableChannelFirst);
-
-  // The debug log displays in reverse order, so the headline is emitted after
-  // the names.
-  for (const auto& pairing : ret) {
-    FIDO_LOG(DEBUG) << "• " << pairing->name << " " << pairing->last_updated
-                    << " priority:" << pairing->channel_priority;
-  }
-  FIDO_LOG(DEBUG) << "Found " << ret.size() << " caBLEv2 devices";
-
-  return ret;
-}
-
 void ChromeAuthenticatorRequestDelegate::HandleCablePairingEvent(
     device::cablev2::PairingEvent event) {
+  PrefService* const prefs =
+      Profile::FromBrowserContext(GetBrowserContext())->GetPrefs();
+
   if (auto* failed_contact_index = absl::get_if<size_t>(&event)) {
     // A pairing was reported to be invalid. Delete it unless it came from Sync,
     // in which case there's nothing to be done.
-    ListPrefUpdate update(
-        Profile::FromBrowserContext(GetBrowserContext())->GetPrefs(),
-        kWebAuthnCablePairingsPrefName);
-    DeleteCablePairingByPublicKey(
-        update.Get(), Base64(phone_public_keys_[*failed_contact_index]));
+    cablev2::DeletePairingByPublicKey(
+        prefs, phone_public_keys_[*failed_contact_index]);
 
     if (weak_dialog_model_) {
       // Contact the next phone with the same name, if any, given that no
@@ -986,47 +722,7 @@
     return;
   }
 
-  // This is called when doing a QR-code pairing with a phone and the phone
-  // sends long-term pairing information during the handshake. The pairing
-  // information is saved in preferences for future operations.
-  if (!base::FeatureList::IsEnabled(device::kWebAuthPhoneSupport)) {
-    NOTREACHED();
-    return;
-  }
-
-  // For Incognito/Guest profiles, pairings will only last for the duration of
-  // that session. While an argument could be made that it's safe to persist
-  // such pairing for longer, this seems like the safe option initially.
-  ListPrefUpdate update(
-      Profile::FromBrowserContext(GetBrowserContext())->GetPrefs(),
-      kWebAuthnCablePairingsPrefName);
-
-  // Otherwise the event is a new pairing.
   auto& pairing =
       *absl::get_if<std::unique_ptr<device::cablev2::Pairing>>(&event);
-  // Find any existing entries with the same public key and replace them. The
-  // handshake protocol requires the phone to prove possession of the public
-  // key so it's not possible for an evil phone to displace another's pairing.
-  std::string public_key_base64 = Base64(pairing->peer_public_key_x962);
-  DeleteCablePairingByPublicKey(update.Get(), public_key_base64);
-
-  auto dict = std::make_unique<base::Value>(base::Value::Type::DICTIONARY);
-  dict->SetKey(kPairingPrefPublicKey,
-               base::Value(std::move(public_key_base64)));
-  dict->SetKey(kPairingPrefTunnelServer,
-               base::Value(pairing->tunnel_server_domain));
-  dict->SetKey(kPairingPrefName, base::Value(std::move(pairing->name)));
-  dict->SetKey(kPairingPrefContactId, base::Value(Base64(pairing->contact_id)));
-  dict->SetKey(kPairingPrefId, base::Value(Base64(pairing->id)));
-  dict->SetKey(kPairingPrefSecret, base::Value(Base64(pairing->secret)));
-
-  base::Time::Exploded now;
-  base::Time::Now().UTCExplode(&now);
-  dict->SetKey(kPairingPrefTime,
-               // RFC 3339 time format.
-               base::Value(base::StringPrintf(
-                   "%04d-%02d-%02dT%02d:%02d:%02dZ", now.year, now.month,
-                   now.day_of_month, now.hour, now.minute, now.second)));
-
-  update->Append(std::move(dict));
+  cablev2::AddPairing(prefs, std::move(pairing));
 }
diff --git a/chrome/browser/webauthn/chrome_authenticator_request_delegate.h b/chrome/browser/webauthn/chrome_authenticator_request_delegate.h
index 79021bd..53276a7 100644
--- a/chrome/browser/webauthn/chrome_authenticator_request_delegate.h
+++ b/chrome/browser/webauthn/chrome_authenticator_request_delegate.h
@@ -190,10 +190,6 @@
   // information that will be broadcast by the device.
   bool ShouldPermitCableExtension(const url::Origin& origin);
 
-  // GetCablePairings returns any known caBLE pairing data.
-  virtual std::vector<std::unique_ptr<device::cablev2::Pairing>>
-  GetCablePairings();
-
   void HandleCablePairingEvent(device::cablev2::PairingEvent pairing);
 
   const content::GlobalRenderFrameHostId render_frame_host_id_;
diff --git a/chrome/browser/webauthn/chrome_webauthn_browsertest.cc b/chrome/browser/webauthn/chrome_webauthn_browsertest.cc
index 0e87ed1..de339e89e 100644
--- a/chrome/browser/webauthn/chrome_webauthn_browsertest.cc
+++ b/chrome/browser/webauthn/chrome_webauthn_browsertest.cc
@@ -419,21 +419,21 @@
       kGetAssertionCredID1234, &result));
 
   constexpr char kExpectedTrace[] = R"(
-PAIRING: name2 02020202 040506
 PAIRING: aaa 03030303 040506
-PAIRING: zzz 04040404 040506
+PAIRING: name2 02020202 040506
 PAIRING: name2 01010101 040506
 PAIRING: name2 00000000 040506
+PAIRING: zzz 04040404 040506
 UINAME: aaa
 UINAME: name2
 UINAME: zzz
-CONTACT: phone_instance=0 step=0
-CONTACT: phone_instance=3 step=1
-CONTACT: phone_instance=4 step=2
-CONTACT: phone_instance=2 step=3
-CONTACT: phone_instance=1 step=4
+CONTACT: phone_instance=1 step=0
+CONTACT: phone_instance=2 step=1
+CONTACT: phone_instance=3 step=2
+CONTACT: phone_instance=4 step=3
+CONTACT: phone_instance=0 step=4
 )";
-  EXPECT_EQ(trace_.str(), kExpectedTrace);
+  EXPECT_EQ(kExpectedTrace, trace_.str());
   EXPECT_EQ("webauthn: OK", result);
 }
 
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 0b6f0ca..98598ba 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -5062,6 +5062,7 @@
       "../browser/upgrade_detector/mock_build_state_observer.h",
       "../browser/upgrade_detector/upgrade_detector_unittest.cc",
       "../browser/webauthn/authenticator_request_scheduler_unittest.cc",
+      "../browser/webauthn/cablev2_devices_unittest.cc",
       "../browser/webauthn/chrome_authenticator_request_delegate_unittest.cc",
       "../renderer/cart/commerce_hint_agent_unittest.cc",
     ]
diff --git a/device/fido/cable/cable_discovery_data.cc b/device/fido/cable/cable_discovery_data.cc
index 282c89d..d629c94 100644
--- a/device/fido/cable/cable_discovery_data.cc
+++ b/device/fido/cable/cable_discovery_data.cc
@@ -6,6 +6,8 @@
 
 #include <cstring>
 
+#include "base/i18n/string_compare.h"
+#include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "components/cbor/values.h"
 #include "crypto/random.h"
@@ -70,6 +72,22 @@
 
 namespace cablev2 {
 
+Pairing::NameComparator::NameComparator(const icu::Locale* locale) {
+  UErrorCode error = U_ZERO_ERROR;
+  collator_.reset(icu::Collator::createInstance(*locale, error));
+}
+
+Pairing::NameComparator::NameComparator(NameComparator&&) = default;
+
+Pairing::NameComparator::~NameComparator() = default;
+
+bool Pairing::NameComparator::operator()(const std::unique_ptr<Pairing>& a,
+                                         const std::unique_ptr<Pairing>& b) {
+  return base::i18n::CompareString16WithCollator(
+             *collator_, base::UTF8ToUTF16(a->name),
+             base::UTF8ToUTF16(b->name)) == UCOL_LESS;
+}
+
 Pairing::Pairing() = default;
 Pairing::~Pairing() = default;
 
@@ -141,6 +159,11 @@
 }
 
 // static
+Pairing::NameComparator Pairing::CompareByName(const icu::Locale* locale) {
+  return NameComparator(locale);
+}
+
+// static
 bool Pairing::EqualPublicKeys(const std::unique_ptr<Pairing>& a,
                               const std::unique_ptr<Pairing>& b) {
   return a->peer_public_key_x962 == b->peer_public_key_x962;
diff --git a/device/fido/cable/cable_discovery_data.h b/device/fido/cable/cable_discovery_data.h
index aef0ff3..248de04 100644
--- a/device/fido/cable/cable_discovery_data.h
+++ b/device/fido/cable/cable_discovery_data.h
@@ -15,6 +15,8 @@
 #include "device/fido/fido_constants.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "third_party/abseil-cpp/absl/types/variant.h"
+#include "third_party/icu/source/common/unicode/locid.h"
+#include "third_party/icu/source/i18n/unicode/coll.h"
 
 namespace cbor {
 class Value;
@@ -66,12 +68,12 @@
   CableDiscoveryData& operator=(const CableDiscoveryData& other);
   bool operator==(const CableDiscoveryData& other) const;
 
-  // MatchV1 returns true if |candidate_eid| matches this caBLE discovery
+  // MatchV1 returns true if `candidate_eid` matches this caBLE discovery
   // instance, which must be version one.
   bool MatchV1(const CableEidArray& candidate_eid) const;
 
   // version indicates whether v1 or v2 data is contained in this object.
-  // |INVALID| is not a valid version but is set as the default to catch any
+  // `INVALID` is not a valid version but is set as the default to catch any
   // cases where the version hasn't been set explicitly.
   Version version = Version::INVALID;
 
@@ -92,14 +94,31 @@
 // Pairing represents information previously received from a caBLEv2
 // authenticator that enables future interactions to skip scanning a QR code.
 struct COMPONENT_EXPORT(DEVICE_FIDO) Pairing {
+  // NameComparator is a less-than operation for sorting `Pairing` by name.
+  // See `CompareByName`.
+  class COMPONENT_EXPORT(DEVICE_FIDO) NameComparator {
+   public:
+    explicit NameComparator(const icu::Locale* locale);
+    NameComparator(NameComparator&&);
+    NameComparator(const NameComparator&) = delete;
+    NameComparator& operator=(const NameComparator&) = delete;
+    ~NameComparator();
+
+    bool operator()(const std::unique_ptr<Pairing>&,
+                    const std::unique_ptr<Pairing>&);
+
+   private:
+    std::unique_ptr<icu::Collator> collator_;
+  };
+
   Pairing();
   ~Pairing();
   Pairing(const Pairing&) = delete;
   Pairing& operator=(const Pairing&) = delete;
 
-  // Parse builds a |Pairing| from an authenticator message. The signature
-  // within the structure is validated by using |local_identity_seed| and
-  // |handshake_hash|.
+  // Parse builds a `Pairing` from an authenticator message. The signature
+  // within the structure is validated by using `local_identity_seed` and
+  // `handshake_hash`.
   static absl::optional<std::unique_ptr<Pairing>> Parse(
       const cbor::Value& cbor,
       tunnelserver::KnownDomainID domain,
@@ -112,6 +131,7 @@
                                                const std::unique_ptr<Pairing>&);
   static bool CompareByPublicKey(const std::unique_ptr<Pairing>&,
                                  const std::unique_ptr<Pairing>&);
+  static NameComparator CompareByName(const icu::Locale* locale);
   static bool EqualPublicKeys(const std::unique_ptr<Pairing>&,
                               const std::unique_ptr<Pairing>&);
 
@@ -135,13 +155,18 @@
   std::string name;
   // last_updated is populated for pairings learned from Sync.
   base::Time last_updated;
-  // channel_priority is populated for pairing learned from Sync. It contains
-  // a higher number for less stable release channels (i.e. Canary is high,
-  // development builds are highest).
+  // from_sync_deviceinfo is true iff this `Pairing` was derived from a
+  // DeviceInfo record in Sync, rather than from scanning a QR code. (Note that
+  // the results of QR scanning may also be distributed via Sync, but that
+  // wouldn't cause this value to be true.)
+  bool from_sync_deviceinfo = false;
+  // channel_priority is populated when `from_sync_deviceinfo` is true. It
+  // contains a higher number for less stable release channels (i.e. Canary is
+  // high, development builds are highest).
   int channel_priority = 0;
 };
 
-// A PairingEvent is either a new |Pairing|, learnt from a device, or else the
+// A PairingEvent is either a new `Pairing`, learnt from a device, or else the
 // index of a pairing has been discovered to be invalid.
 using PairingEvent = absl::variant<std::unique_ptr<Pairing>, size_t>;
 
